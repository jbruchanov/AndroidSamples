package com.scurab.android.features.security.keystore

import android.os.Build
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import androidx.annotation.RequiresApi
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec


interface IEncryptionDecryption {
    /**
     * Encrypt data
     */
    fun encrypt(plainText: ByteArray): ByteArray

    /**
     * Decrypt data
     */
    fun decrypt(cipherText: ByteArray): ByteArray
}

/**
 * Wrapper for default Android Keystore
 * Simple implementation of enc/dec using symmetric AES-256 cipher
 */
@RequiresApi(Build.VERSION_CODES.M)
class KeyStoreWrapper : IEncryptionDecryption {

    private var secretKey: SecretKey

    init {
        secretKey = getOrCreateKey(ALIAS_NET_SEC)
    }

    override fun encrypt(plainText: ByteArray): ByteArray {
        val cipherText = ByteArray(IV_SIZE_IN_BYTES + plainText.size + TAG_SIZE_IN_BYTES)
        val cipher = Cipher.getInstance(TRANSFORMATION)
        cipher.init(Cipher.ENCRYPT_MODE, secretKey)
        cipher.doFinal(plainText, 0, plainText.size, cipherText, IV_SIZE_IN_BYTES)
        // Copy the IV vector generated by Android Keystore into cipher result (necessary for decryption)
        System.arraycopy(cipher.iv, 0, cipherText, 0, IV_SIZE_IN_BYTES)
        return cipherText
    }

    override fun decrypt(cipherText: ByteArray): ByteArray {
        val cipher = Cipher.getInstance(TRANSFORMATION)
        val params = gcmParameterSpec(cipherText);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, params)
        return cipher.doFinal(cipherText, IV_SIZE_IN_BYTES, cipherText.size - IV_SIZE_IN_BYTES)
    }

    private fun gcmParameterSpec(msg: ByteArray) =
        GCMParameterSpec(TAG_SIZE_IN_BYTES * 8, msg, 0, IV_SIZE_IN_BYTES)

    companion object {
        /**
         * Predefined key sizes for [KeyGenParameterSpec]
         */
        const val KEY_SIZE = 256

        const val ANDROID_PROVIDER = "AndroidKeyStore"

        /**
         * Default alias used for KeyStore
         */
        private const val ALIAS_NET_SEC = "_SimpleKeyStoreAlias"

        /**
         * Expected IV vector size
         */
        private const val IV_SIZE_IN_BYTES = 12
        /**
         * Default GCM Tag size
         * TODO("What is correct value here ?") 16 is in
         * com.google.crypto.tink.integration.android.AndroidKeystoreAesGcm
         * But web is recommending at least 128 ?!
         */
        private const val TAG_SIZE_IN_BYTES = 16

        /**
         * Enforce to have use PIN/FP/... as a "lock"
         */
        private const val USE_USER_AUTH_IN_PHONE = false
        /**
         * Default transformation used for enc/dec
         */
        private const val TRANSFORMATION = "${KeyProperties.KEY_ALGORITHM_AES}/" +
                "${KeyProperties.BLOCK_MODE_GCM}/" + KeyProperties.ENCRYPTION_PADDING_NONE

        @JvmStatic
        private fun createAES256GCMKeyGenParameterSpec(
            keyAlias: String
        ): KeyGenParameterSpec {
            val builder = KeyGenParameterSpec.Builder(
                keyAlias,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
            )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                //duration necessary for for encrypted shared prefs
                .apply {
                    if (USE_USER_AUTH_IN_PHONE) {
                        setUserAuthenticationRequired(true)
                        //timeout necessary, otherwise it's crashing because of unclear "invalid-padding/size" or similar
                        //exception
                        setUserAuthenticationValidityDurationSeconds(120)
                    }
                }
                .setKeySize(KEY_SIZE)
            return builder.build()
        }

        /**
         * Get or generate [SecretKey] if necessary.
         * It might throw a [RuntimeException] if [KeyGenerator] can't generate a key
         */
        @JvmStatic
        fun getOrCreateKey(alias: String): SecretKey {
            val keyStore = KeyStore.getInstance(ANDROID_PROVIDER)
            keyStore.load(null)
            var key = (keyStore.getEntry(alias, null) as? KeyStore.SecretKeyEntry)?.secretKey
            if (key == null) {
                val keyGenerator =
                    KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_PROVIDER)
                keyGenerator.init(createAES256GCMKeyGenParameterSpec(ALIAS_NET_SEC))
                key = keyGenerator.generateKey()
                    ?: throw IllegalStateException("Unable to generate key")
            }
            return key
        }
    }
}